<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<TITLE>Function reference</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<OBJECT TYPE="application/x-oleobject" CLASSID="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
	<PARAM NAME="Keyword" VALUE="functions">
	<PARAM NAME="Keyword" VALUE="operators">
</OBJECT>

<A NAME="reference"></A><B>Function reference</B>

<TABLE>
<TR><TD width="100pt"><CODE>+</CODE></TD><TD>addition</TD></TR>

<TR><TD><CODE>-</CODE></TD><TD>subtraction</TD></TR>

<TR><TD><CODE>*</CODE></TD><TD>multiplication</TD></TR>

<TR><TD><CODE>/</CODE></TD><TD>division</TD></TR>

<TR><TD>div</TD><TD><CODE>x div y= trunc(x/y)</CODE></TD></TR>

<TR><TD>mod</TD><TD>remainder,   <CODE>x mod y= x-y*(x div y)</CODE></TD></TR>

<TR><TD>hypot</TD><TD>hypotenuse,   <CODE>hypot(a,b)=sqrt(a^2+b^2)</CODE></TD></TR>

<TR><TD>angle</TD><TD><CODE>angle(a,b)= atan(a/b)</CODE></TD></TR>

<TR><TD>rand</TD><TD>random number,  <CODE>0&lt;=rand&lt;1</CODE></TD></TR>

<TR><TD>random</TD><TD><CODE>random(n)=trunc(rand*n)</CODE></TD></TR>

<TR><TD>ctof</TD><TD>converts °Celsius to °Fahrenheit</TD></TR>

<TR><TD>ftoc</TD><TD>converts °Fahrenheit to °Celsius</TD></TR>

<TR><TD>baseN</TD><TD>next number is in base N,   2&lt;=N&lt;=36, there is no space before N</TD></TR>

<TR><TD>dec</TD><TD>base10</TD></TR>

<TR><TD>hex</TD><TD>base16</TD></TR>

<TR><TD>bin</TD><TD>base2</TD></TR>

<TR><TD>oct</TD><TD>base8</TD></TR>

</TABLE>
<TABLE>
<TR><TD colspan="2"><U>powers and logarithms</U></TD></TR>

<TR><TD width="100pt">^, <CODE>**</CODE></TD><TD>power</TD></TR>

<TR><TD><CODE>#</CODE></TD><TD>root,    <CODE>y#x= x^(1/y)</CODE></TD></TR>

<TR><TD>sqrt</TD><TD>square root,    <CODE>sqrt(x)= 2#x = x^0.5</CODE></TD></TR>

<TR><TD>exp</TD><TD>exponential function,   <CODE>exp(x)=e^x, e=2.718...</CODE></TD></TR>

<TR><TD>ln</TD><TD>natural logarithm, inverse function to exp</TD></TR>

<TR><TD>logn</TD><TD>logarithm,    <CODE>logn(n,x)=ln(x)/ln(n)</CODE></TD></TR>

<TR><TD>log</TD><TD><CODE>log(x)=logn(10,x)</CODE></TD></TR>

</TABLE>
<A NAME="complex"></A>
<TABLE>
<TR><TD colspan="2"><U>complex numbers</U></TD></TR>

<TR><TD width="100pt">real</TD><TD>real part,   <CODE>real(a+bi)=a</CODE></TD></TR>

<TR><TD>imag</TD><TD>imaginary part,   <CODE>imag(a+bi)=b</CODE></TD></TR>

<TR><TD>conjg</TD><TD>conjugate,   <CODE>conjg(a+bi)=a-bi</CODE></TD></TR>

<TR><TD>abs</TD><TD>absolute value,   <CODE>abs x=hypot(real x,imag x)</CODE></TD></TR>

<TR><TD>arg</TD><TD>phase angle,     <CODE>arg x=angle(imag x,real x)</CODE></TD></TR>

<TR><TD>sign</TD><TD><CODE>sign x=x/abs x</CODE></TD></TR>

<TR><TD>polar</TD><TD><CODE>polar(r,a)=r*cos a + i*r*sin a</CODE></TD></TR>

<TR><TD>complex</TD><TD><CODE>complex(a,b)= a + b i</CODE></TD></TR>

</TABLE>
<A NAME="commands"></A>
<TABLE>
<TR><TD colspan="2"><U>conditions and commands</U></TD></TR>

<TR><TD width="100pt">==</TD><TD>1 if operands are equal, 0 otherwise</TD></TR>

<TR><TD>!=, &lt;&gt;</TD><TD>not equal</TD></TR>

<TR><TD>&gt;</TD><TD>greater</TD></TR>

<TR><TD>&lt;</TD><TD>less</TD></TR>

<TR><TD>&gt;=</TD><TD>greater or equal</TD></TR>

<TR><TD>&lt;=</TD><TD>less or equal</TD></TR>

<TR><TD>if(p,a,b)</TD><TD>b if p is zero, or a if p is not zero</TD></TR>

<TR><TD>return</TD><TD>stops computation</TD></TR>

<TR><TD>return x</TD><TD>stops computation and displays result x</TD></TR>

<TR><TD>goto n</TD><TD>jump to a label or to the n-th semicolon,  goto0 jumps to the beginning </TD></TR>

<TR><TD>gotor n</TD><TD>relative jump,  gotor <CODE>-</CODE>1 jumps to the previous command, gotor1 jump to next command,  gotor0 will freeze the calculator</TD></TR>

<TR><TD>print x,"t"</TD><TD>prints number x and then text t</TD></TR>

<TR><TD>swap(a,b)</TD><TD>exchange variables a,b</TD></TR>

</TABLE>
<TABLE>
<TR><TD colspan="2"><U>rounding</U></TD></TR>

<TR><TD width="100pt">round</TD><TD>round to the nearest integer</TD></TR>

<TR><TD>int, floor</TD><TD>round down</TD></TR>

<TR><TD>ceil</TD><TD>round up</TD></TR>

<TR><TD>trunc</TD><TD>integer part</TD></TR>

<TR><TD>frac</TD><TD>fractional part,   <CODE>frac x=x-trunc x</CODE></TD></TR>

</TABLE>
<A NAME="bitwise"></A>
<TABLE>
<TR><TD colspan="2"><U>bitwise functions</U></TD></TR>

<TR><TD width="100pt">and, &amp;</TD><TD>bitwise and</TD></TR>

<TR><TD>or, |</TD><TD>bitwise or</TD></TR>

<TR><TD>xor</TD><TD>bitwise exclusive or</TD></TR>

<TR><TD>not</TD><TD>the one's complement of the integer part</TD></TR>

<TR><TD>bitnand</TD><TD><CODE>x bitnand y=not(x and y)</CODE></TD></TR>

<TR><TD>nand</TD><TD><CODE>x nand y=(x==0 or y==0)</CODE></TD></TR>

<TR><TD>bitnor</TD><TD><CODE>x bitnor y=not(x or y)</CODE></TD></TR>

<TR><TD>nor</TD><TD><CODE>x nor y=(x==0 and y==0)</CODE></TD></TR>

<TR><TD>bitimp</TD><TD><CODE>x bitimp y=y or not x</CODE></TD></TR>

<TR><TD>imp, -&gt;</TD><TD><CODE>x imp y=(x==0 or y&lt;&gt;0)</CODE></TD></TR>

<TR><TD>biteqv</TD><TD><CODE>x biteqv y= not(x xor y)</CODE></TD></TR>

<TR><TD>eqv</TD><TD><CODE>x eqv y=((x==0)==(y==0))</CODE></TD></TR>

<TR><TD>lsh, &lt;&lt;</TD><TD>shift left,   <CODE>x&lt;&lt;y=x*2^y</CODE></TD></TR>

<TR><TD>rsh, &gt;&gt;</TD><TD>shift right,   <CODE>x&gt;&gt;y=x&lt;&lt;-y</CODE></TD></TR>

<TR><TD>rshi, &gt;&gt;&gt;</TD><TD><CODE>x&gt;&gt;&gt;y=trunc(x&gt;&gt;y)</CODE></TD></TR>

</TABLE>
<A NAME="integer"></A>
<TABLE>
<TR><TD colspan="2"><U>integer functions</U></TD></TR>

<TR><TD width="100pt">!, fact</TD><TD>factorial,    <CODE>n!=fact(n)= productfor(i,1,n,i)</CODE></TD></TR>

<TR><TD>!!, ffact</TD><TD><CODE>n!!=ffact(n)= productfor(i,0,n/2-1,n-2*i)</CODE></TD></TR>

<TR><TD>combin, nCr</TD><TD>combination,    <CODE>n nCr k = n!/(n-k)!/k!</CODE></TD></TR>

<TR><TD>permut, nPr</TD><TD>variation,     <CODE>n nPr k = n!/(n-k)!</CODE></TD></TR>

<TR><TD>gcd</TD><TD>the greatest common divisor of two or more integers</TD></TR>

<TR><TD>lcm</TD><TD>the least common multiple of two or more integers,   <CODE>lcm(a,b)=a*b/gcd(a,b)</CODE></TD></TR>

<TR><TD>divisor</TD><TD>the least prime divisor of an operand</TD></TR>

<TR><TD>prime</TD><TD>prime that is greater then an operand</TD></TR>

<TR><TD>isprime</TD><TD><CODE>isprime(n)=(divisor(n)==n)</CODE></TD></TR>

<TR><TD>fibon</TD><TD>Fibonacci,  <CODE>fibon(n)=fibon(n-1)+fibon(n-2)</CODE></TD></TR>

</TABLE>
<A NAME="angle"></A>
<TABLE>
<TR><TD colspan="2"><U>angle conversions</U></TD></TR>

<TR><TD width="100pt">radtodeg</TD><TD>converts radians to degrees, <CODE>radtodeg x= x/pi*180</CODE></TD></TR>

<TR><TD>degtorad</TD><TD>converts degrees to radians</TD></TR>

<TR><TD>radtograd</TD><TD>converts radians to gradients, <CODE>radtograd x= x/pi*200</CODE></TD></TR>

<TR><TD>gradtorad</TD><TD>converts gradients to radians</TD></TR>

<TR><TD>degtograd</TD><TD>converts degrees to gradients, <CODE>degtograd x= x*10/9</CODE></TD></TR>

<TR><TD>gradtodeg</TD><TD>converts gradients to degrees</TD></TR>

<TR><TD>deg , °</TD><TD>converts degrees to the current units</TD></TR>

<TR><TD>rad</TD><TD>converts radians to the current units</TD></TR>

<TR><TD>grad</TD><TD>converts gradients to the current units</TD></TR>

<TR><TD>todeg</TD><TD>converts the current units to degrees</TD></TR>

<TR><TD>torad</TD><TD>converts the current units to radians</TD></TR>

<TR><TD>tograd</TD><TD>converts the current units to gradients</TD></TR>

<TR><TD>dms</TD><TD>converts degrees, minutes and seconds to degrees, the integer part is degrees, two digits after a decimal point are minutes, next two digits are seconds, next digits are tenth of a second, hundredth of a second, ... </TD></TR>

<TR><TD>todms</TD><TD>inverse function to dms</TD></TR>

</TABLE>
<TABLE>
<TR><TD colspan="2"><U>trigonometric functions</U></TD></TR>

<TR><TD width="100pt">sin</TD><TD>sine, (opposite side / hypotenuse)</TD></TR>

<TR><TD>cos</TD><TD>cosine, (adjacent side / hypotenuse)</TD></TR>

<TR><TD>tan, tg</TD><TD>tangent, (opposite side / adjacent side)</TD></TR>

<TR><TD>cosec, csc</TD><TD>cosecant, (hypotenuse / opposite side)</TD></TR>

<TR><TD>sec</TD><TD>secant, (hypotenuse / adjacent side)</TD></TR>

<TR><TD>cot, cotg</TD><TD>cotangent, (adjacent side / opposite side)</TD></TR>

</TABLE>
<TABLE>
<TR><TD colspan="2"><U>inverse trigonometric functions</U></TD></TR>

<TR><TD width="150pt">asin, arcsin</TD><TD><CODE>asin(x)=-ln(x i+sqrt(1-x^2)) i</CODE></TD></TR>

<TR><TD>acos, arccos</TD><TD><CODE>acos(x)=-ln(x+sqrt(1-x^2) i) i</CODE></TD></TR>

<TR><TD>atan, atg, arctan, arctg</TD><TD><CODE>atan(x)=(ln(1+x i)-ln(1-x i))/2i</CODE></TD></TR>

<TR><TD>acsc</TD><TD><CODE>acsc(x)=asin(1/x)</CODE></TD></TR>

<TR><TD>asec</TD><TD><CODE>asec(x)=acos(1/x)</CODE></TD></TR>

<TR><TD>acot, acotg, arccot, arccotg</TD><TD><CODE>acot(x)=atan(1/x)</CODE></TD></TR>

</TABLE>
<TABLE>
<TR><TD colspan="2"><U>hyperbolic functions</U></TD></TR>

<TR><TD width="100pt">sinh</TD><TD><CODE>sinh(x)=(exp(x)-exp(-x))/2</CODE></TD></TR>

<TR><TD>cosh</TD><TD><CODE>cosh(x)=(exp(x)+exp(-x))/2</CODE></TD></TR>

<TR><TD>tanh, tgh</TD><TD><CODE>tanh(x)=sinh(x)/cosh(x)</CODE></TD></TR>

<TR><TD>csch</TD><TD><CODE>csch(x)=1/sinh(x)</CODE></TD></TR>

<TR><TD>sech</TD><TD><CODE>sech(x)=1/cosh(x)</CODE></TD></TR>

<TR><TD>coth, cotgh</TD><TD><CODE>coth(x)=cosh(x)/sinh(x)</CODE></TD></TR>

</TABLE>
<TABLE>
<TR><TD colspan="2"><U>inverse hyperbolic functions</U></TD></TR>

<TR><TD width="150pt">asinh, argsinh</TD><TD><CODE>asinh(x)=ln(x+sqrt(x^2+1))</CODE></TD></TR>

<TR><TD>acosh, argcosh</TD><TD><CODE>acosh(x)=ln(x+sqrt(x+1)*sqrt(x-1))</CODE></TD></TR>

<TR><TD>atanh, atgh, argtanh, argtgh</TD><TD><CODE>atanh(x)=(ln(1+x)-ln(1-x))/2</CODE></TD></TR>

<TR><TD>acsch</TD><TD><CODE>acsch(x)=asinh(1/x)</CODE></TD></TR>

<TR><TD>asech</TD><TD><CODE>asech(x)=acosh(1/x)</CODE></TD></TR>

<TR><TD>acoth, acotgh, argcoth, argcotgh</TD><TD><CODE>acoth(x)=atanh(1/x)</CODE></TD></TR>

</TABLE>
<A NAME="matrix"></A>
<TABLE>
<TR><TD colspan="2"><U>matrices</U></TD></TR>

<TR><TD colspan="2">+, <CODE>-</CODE>, ==, &lt;&gt;, and, or, xor, lsh, rsh, real, imag, conjg, round, trunc, floor, ceil, frac</TD></TR>

<TR><TD width="100pt">width</TD><TD>number of columns</TD></TR>

<TR><TD>height</TD><TD>number of rows</TD></TR>

<TR><TD>matrix(r,c)</TD><TD>zero matrix which has r rows and c columns</TD></TR>

<TR><TD>count</TD><TD><CODE>count A= width A * height A</CODE></TD></TR>

<TR><TD><CODE>,</CODE></TD><TD>concatenation alongside, operands must have the same number of rows</TD></TR>

<TR><TD><CODE>\</CODE></TD><TD>concatenation below, operands must have the same number of columns</TD></TR>

<TR><TD><CODE>*</CODE></TD><TD>matrix multiplication or scalar multiplication</TD></TR>

<TR><TD>vert</TD><TD>vector product,<CODE> A vert B=(A[1]*B[2]-A[2]*B[1], A[2]*B[0]-A[0]*B[2], A[0]*B[1]-A[1]*B[0])</CODE></TD></TR>

<TR><TD><CODE>/</CODE></TD><TD><CODE>A/B= A*invert B</CODE></TD></TR>

<TR><TD>^</TD><TD><CODE>A^n= productfor(i,1,n,A); A^(-n)=1/(A^n)</CODE></TD></TR>

<TR><TD>invert</TD><TD>inverted matrix,<CODE> invert A= 1/A= A^(-1)</CODE></TD></TR>

<TR><TD>det</TD><TD>determinant</TD></TR>

<TR><TD>rank</TD><TD>count of linearly independent rows</TD></TR>

<TR><TD>transp, '</TD><TD>diagonal symmetry</TD></TR>

<TR><TD>elim</TD><TD>elimination method that makes elementary transformations with rows</TD></TR>

<TR><TD>solve</TD><TD>simultaneous linear equations, every row represents one equation, last column is the right side of equations, (number of columns) = 1 + (number of variables), number of rows is not restricted, but it is usually same as number of variables</TD></TR>

<TR><TD>abs</TD><TD>vector length, matrix norm,<CODE> abs A= sqrt sumq A</CODE></TD></TR>

<TR><TD>angle</TD><TD>angle between two vectors,<CODE> angle(A,B)= acos(A*B/abs(A)/abs(B))</CODE></TD></TR>

<TR><TD>polynom</TD><TD><CODE>polynom(x,A)= sumfor(i,0,count A-1, A[i]*x^i)</CODE></TD></TR>

<TR><TD>reverse</TD><TD>change order of items from last to the first</TD></TR>

<TR><TD>sort</TD><TD>sort items from lesser to greater</TD></TR>

<TR><TD>sortd</TD><TD>sort items from greater to lesser, <CODE>sortd A= reverse sort A</CODE></TD></TR>

</TABLE>
<A NAME="for"></A>
<TABLE>
<TR><TD colspan="2"><U>cycles</U></TD></TR>

<TR><TD width="150pt">for(x,a,b,f(x))</TD><TD>values from a to b are assigned to variable x and command f is executed, result is 0, f can modify variables, f can contain command if, return, ...</TD></TR>

<TR><TD>foreach(x,A,f(x))</TD><TD>this function is similar to for except that every element of matrix A is assigned to variable x</TD></TR>

<TR><TD>listfor(x,a,b,f(x))</TD><TD>row vector which contains values f(x) where x is from a to b. If f(x) returns column vectors, then listfor returns matrix. If a&gt;b then listfor returns 0.</TD></TR>

<TR><TD>rowsfor(x,a,b,f(x))</TD><TD>column vector which contains values f(x) where x is from a to b. If f(x) returns row vectors, then rowsfor returns matrix. If a&gt;b then rowsfor returns 0.</TD></TR>

<TR><TD>sumfor(x,a,b,f(x))</TD><TD><CODE>sum(listfor(x,a,b,f(x)))</CODE></TD></TR>

<TR><TD>productfor(x,a,b,f(x))</TD><TD><CODE>if(a>b,1,product(listfor(x,a,b,x))</CODE></TD></TR>

<TR><TD>minfor(x,a,b,f(x))</TD><TD><CODE>min(listfor(x,a,b,f(x)))</CODE></TD></TR>

<TR><TD>maxfor(x,a,b,f(x))</TD><TD><CODE>max(listfor(x,a,b,f(x)))</CODE></TD></TR>

<TR><TD colspan="2">sumforeach, productforeach, listforeach, rowsforeach, minforeach, maxforeach - these functions are similar to the foregoing functions, but the x values are taken from matrix A</TD></TR>

<TR><TD>integral(x,a,b,n,f(x))</TD><TD>integral from a to b from function f(x), n is precision (number of correct decimal digits, other digits are wrong !), if n&gt;=100 then n is duration in milliseconds</TD></TR>

</TABLE>
<A NAME="statistics"></A>
<TABLE>
<TR><TD colspan="2"><U>statistical functions</U></TD></TR>

<TR><TD width="100pt">min</TD><TD>minimal value</TD></TR>

<TR><TD>max</TD><TD>maximal value</TD></TR>

<TR><TD>med</TD><TD>median, middle value</TD></TR>

<TR><TD>mode</TD><TD>most frequent value</TD></TR>

<TR><TD>sum</TD><TD><CODE>sum A= A[0]+A[1]+ ... + A[count A-1]</CODE></TD></TR>

<TR><TD>product</TD><TD><CODE>product A= A[0]*A[1]* ... * A[count A-1]</CODE></TD></TR>

<TR><TD>sumq</TD><TD>sum of squared values,   <CODE>sumq A= sumforeach(x,A,x^2)</CODE></TD></TR>

<TR><TD>ave, mean</TD><TD>mean,   <CODE>ave A= sum A/count A</CODE></TD></TR>

<TR><TD>aveq, meanq</TD><TD>mean of squared values,   <CODE>aveq A= sumq A/count A</CODE></TD></TR>

<TR><TD>geom</TD><TD>geometric mean,<BR><CODE>geom A= (count A)#product A</CODE></TD></TR>

<TR><TD>agm</TD><TD>arithmeticgeometric mean</TD></TR>

<TR><TD>harmon</TD><TD>harmonic mean, <CODE>harmon A= count A / sumforeach(x,A,1/x)</CODE></TD></TR>

<TR><TD>var</TD><TD>variance,   <CODE>var A= (sumq A-(sum A)^2/count A)/(count A-1)</CODE></TD></TR>

<TR><TD>vara</TD><TD>variance of population,<BR><CODE>vara A= aveq A-(ave A)^2</CODE></TD></TR>

<TR><TD>stdev</TD><TD>standard deviation,<BR><CODE>stdev A= sqrt(var A)</CODE></TD></TR>

<TR><TD>stdeva</TD><TD>standard deviation of population,<BR><CODE>stdeva A= sqrt(vara A)</CODE></TD></TR>

</TABLE>
<TABLE>
<TR><TD colspan="2"><U>linear regression</U></TD></TR>

<TR><TD colspan="2">Points in a plane are represented by a matrix which has two columns. The first column contains x coordinates, the second column contains y coordinates. Functions lra and lrb get coeficients of line y=a+b*x which goes through the points. If all points are exactly on the line, then function lrr returns +1 or -1.</TD></TR>

<TR><TD width="100pt">lra</TD><TD><CODE>lra D= (sumy D-lrb D*sumx D)/height D</CODE></TD></TR>

<TR><TD>lrb</TD><TD><CODE>lrb D= (height D*sumxy D-sumx D*sumy D)/(height D*sumxq D-(sumx D)^2)</CODE></TD></TR>

<TR><TD>lrr</TD><TD>correlation coeficient, <CODE>lrr D= (height D*sumxy D-sumx D*sumy D)/sqrt((height D*sumxq D-(sumx D)^2)*(height D*sumyq D-(sumy D)^2))</CODE></TD></TR>

<TR><TD>lrx</TD><TD><CODE>lrx(D,y)= (y-lra D)/lrb D</CODE></TD></TR>

<TR><TD>lry</TD><TD><CODE>lry(D,x)= lra D + x*lrb D</CODE></TD></TR>

<TR><TD>sumx</TD><TD><CODE>sumx D= sum D[][0]</CODE></TD></TR>

<TR><TD>sumy</TD><TD><CODE>sumy D= sum D[][1]</CODE></TD></TR>

<TR><TD>sumxy</TD><TD><CODE>sumxy D= D[][0]*D[][1]</CODE></TD></TR>

<TR><TD colspan="2">sumxq, sumyq, avex, avey, avexq, aveyq, varx, vary, varxa, varya, stdevx, stdevy, stdevxa, stdevya</TD></TR>
</TABLE>
</BODY>
</HTML>
